{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"azint","text":"<p>azint is a python library for azimuthal integration of area detectors. The azimuthal integration is transformed into a sparse matrix vector multiplication for performance. Pixel splitting is done by subdividing  each pixels into subpixels and assigning bins and weights for the individual subpixels. This can increase the precision of the transformation but also introduces correlation between neighboring bins.</p> <p>The algorithm is described in more detail in this publication. Please cite the paper if you use azint.</p> \\[ I_{bin} = \\frac{ \\sum_{pix \\in bin} c^{pix}_{bin} \\frac{I_{pix}}{\\Omega_{pix} P_{pix}}}{\\sum_{pix \\in bin}c^{pix}_{bin}} \\] <p>with the standard error of the mean</p> \\[ SE_{bin} = \\frac{ \\sqrt{\\sum_{pix \\in bin} (c^{pix}_{bin})^2 \\frac{\\sigma^2_{pix}}{\\Omega_{pix}^2 P_{pix}^2}}}{\\sum_{pix \\in bin}c^{pix}_{bin}} \\] <p>The only error model implementent at the moment is the poisson error model with \\(\\sigma_{pix} = \\sqrt{I_{pix}}\\)</p>"},{"location":"#geometry","title":"Geometry","text":"<p>The geometry in azint is identical to pyFAI to be compatible with poni files generated by pyFAI  </p>"},{"location":"#installation","title":"Installation","text":"<pre><code>conda install -c maxiv azint\n</code></pre>"},{"location":"#getting-started","title":"Getting started","text":"<p>azint is using poni files from pyFAI to setup the azimuthal integrator (link to file examples and output) <pre><code>import numpy as np\nfrom azint import AzimuthalIntegrator\n\n# ------------------------------\n# Load detector image and setup\n# ------------------------------\n\n# Path to the input HDF5 file containing detector data\nh5name = \"scan-1737_pilatus.h5\"\nh = h5py.File(h5name, 'r')\n\n# Extract a single image frame from the dataset\nimg = h['/entry/instrument/pilatus/data'][10]\n\n# Path to the detector calibration file\nponi = 'Si_135mm.poni'\n\n# Path to the mask file for bad pixels or beamstop\nmask = 'hot_px_bs_mask.npy'\n\n\n# ------------------------------\n# Azimuthal integration settings\n# ------------------------------\n\nconfig = {\n    'poni': poni,                     # Detector geometry calibration file\n    'mask': mask,                     # Mask to ignore hot/dead pixels\n    'radial_bins': 3000,              # Number of radial bins\n    'azimuth_bins': 180,              # Number of azimuthal bins (set to None for 1D only)\n    'n_splitting': 21,                # Pixel subdivision for integration precision\n    'error_model': 'poisson',         # Error model for propagation\n    'solid_angle': True,              # Apply solid angle correction\n    'polarization_factor': 0.965,     # Correction for polarization effects\n    'normalized': True,               # Normalize intensity values\n    'unit': '2th',                    # Output units (e.g., '2th' for 2\u03b8)\n}\n\nai = AzimuthalIntegrator(**config)\nI, errors_1d, I_2d, errors_2d = ai.integrate(img)\n\nimport matplotlib.pyplot as plt\nplt.figure()\nplt.plot(ai.radial_axis, I)\n\nplt.figure()\nplt.imshow(I_2d)\n</code></pre></p>"},{"location":"azint-reference/","title":"azint","text":""},{"location":"azint-reference/#azint.azint.AzimuthalIntegrator","title":"<code>AzimuthalIntegrator</code>","text":"<p>This class is an azimuthal integrator</p> Source code in <code>azint/azint.py</code> <pre><code>class AzimuthalIntegrator():\n    \"\"\"\n    This class is an azimuthal integrator \n    \"\"\"\n    def __init__(self,\n                 poni: Union[str, Poni],\n                 n_splitting: int, \n                 radial_bins: Union[int, Sequence],\n                 azimuth_bins: Optional[Union[int, Sequence]] = None,\n                 unit: str = 'q',\n                 mask: Optional[Union[np.ndarray, str]] = None,\n                 solid_angle: bool = True,\n                 polarization_factor: Optional[float] = None,\n                 normalized: bool = True,\n                 error_model: Optional[str] = None):\n        \"\"\"\n        Initializes the integration settings for a 1D or 2D azimuthal integration.\n\n        Attributes:\n            poni (str or dict or Poni): Path to a PONI file or a Poni instance or a dictionary that defines the detector geometry.\n            n_splitting (int): Number of subpixels per dimension for pixel splitting. Each image pixel is split into (n_splitting x n_splitting) subpixels.\n            radial_bins (int or Sequence): Number of radial bins or an explicit sequence of radial bin edges (e.g., in \u00c5\u207b\u00b9 or degrees).\n            azimuth_bins (int or Sequence, optional): Number of azimuthal bins or a sequence of azimuthal bin edges (in degrees from 0 to 360). Required for 2D integration.\n            unit (str): Unit for the radial axis. Typically 'q' (\u00c5\u207b\u00b9) or '2theta' (degrees).\n            mask (ndarray or str, optional): Mask array or path to mask file. Pixels marked with 1 will be excluded from the integration.\n            solid_angle (bool): If True, applies solid angle correction.\n            polarization_factor (float, optional): Polarization correction factor.\n                Use 1 for horizontal polarization, -1 for vertical polarization.\n            normalized (bool, optional): If True, the output will be normalized by the number of contributing pixels.\n            error_model (str, optional): Error model used to propagate uncertainties. Currently, only 'poisson' is supported.\n\n            radial_axis (ndarray): Array of radial coordinates in the specified unit ('q' or '2theta').\n            azimuth_axis (ndarray, optional): Array of azimuthal coordinates in degrees, present if performing 2D integration.\n        \"\"\"\n        self.poni = poni\n        self.n_splitting = n_splitting\n        self.radial_bins = radial_bins\n        self.azimuth_bins = azimuth_bins\n        self.solid_angle = solid_angle\n        self.polarization_factor = polarization_factor\n        self.normalized = normalized\n        self.mask_path = ''\n        if not isinstance(mask, np.ndarray):\n            if mask is not None:\n                if mask == '':\n                    mask = None\n                else:\n                    fname = mask\n                    self.mask_path = fname\n                    ending = os.path.splitext(fname)[1]\n                    if ending == '.npy':\n                        mask = np.load(fname)\n                    else:\n                        mask = fabio.open(fname).data\n        self.mask = mask\n        if error_model and error_model != 'poisson':\n            raise RuntimeError('Only poisson error model is supported')\n\n        if unit not in ('q', '2th'):\n            raise RuntimeError('Wrong radial unit. Allowed units: q, 2th')\n\n        if isinstance(poni, str):\n            poni = Poni.from_file(poni)\n\n        if isinstance(poni, dict):\n            poni = Poni.from_dict(poni)\n\n        self.unit = unit\n        self.error_model = error_model\n\n        pixel_centers = np.mean(poni.det.pixel_corners, axis=2)\n        p1 = pixel_centers[..., 1] - poni.poni1\n        p2 = pixel_centers[..., 2] - poni.poni2\n        p3 = pixel_centers[..., 0] + poni.dist\n        tth, phi = transform(poni, p1, p2, p3)\n\n        radial_bins = setup_radial_bins(poni, radial_bins, unit, tth)\n        self.radial_axis = 0.5*(radial_bins[1:] + radial_bins[:-1])\n        azimuth_bins = setup_azimuth_bins(azimuth_bins)\n        self.azimuth_axis = 0.5*(azimuth_bins[1:] + azimuth_bins[:-1]) if azimuth_bins is not None else None\n\n        shape = pixel_centers.shape[:2]\n        self.input_size = np.prod(shape)\n        if mask is None:\n            mask = np.zeros(shape, dtype=np.int8)\n\n        if azimuth_bins is None:\n            self.output_shape = [len(radial_bins) - 1]\n        else:\n            self.output_shape = [len(azimuth_bins) - 1, len(radial_bins) - 1]\n\n        self.sparse_matrix = Sparse(poni, poni.det.pixel_corners, n_splitting, \n                                    mask, unit, radial_bins, azimuth_bins)\n        self.norm = self.sparse_matrix.spmv(np.ones(shape[0]*shape[1], dtype=np.float32))\n        corrections = setup_corrections(poni, solid_angle, polarization_factor, p1, p2, tth, phi)\n        self.sparse_matrix.set_correction(corrections)\n\n\n    def integrate(self, \n                  img: np.ndarray) -&gt; tuple[np.ndarray, np.ndarray]:\n        \"\"\"\n        Performs azimuthal integration on the input image.\n\n        This function computes the azimuthally averaged intensity from the input image\n        using a sparse matrix-based integration approach. Optionally applies a mask\n        and computes error estimates if an error model is defined.\n\n        Args:\n            img (ndarray): Input image to be integrated. Must match expected input size.\n\n        Returns:\n            tuple:\n                - I (ndarray): 1D azimuthally integrated intensity.\n                - errors_1d (ndarray or None): Standard error of the mean (SEM) for 1D integration if error model is specified, else None.\n                - I_2d (None): 2D \"cake\" integration result.\n                - errors_2d (None): 2D error result.\n\n        Raises:\n            RuntimeError: If the input image size does not match the expected size.\n        \"\"\"\n        img = np.ascontiguousarray(img)\n\n        if img.size != self.input_size:\n            raise RuntimeError('Size of image is wrong!\\nExpected %d\\nActual size %d' %(self.input_size, img.size))\n        if self.mask is None:\n            norm = self.norm\n        else:\n            inverted_mask = 1 - self.mask\n            img = img*inverted_mask\n            norm = self.sparse_matrix.spmv(inverted_mask.reshape(-1))\n\n        signal = self.sparse_matrix.spmv_corrected(img).reshape(self.output_shape)\n        norm = norm.reshape(self.output_shape)\n\n        errors = None\n        errors_1d = None\n        errors_2d = None\n        if self.error_model:\n            # poisson error model\n            errors = np.sqrt(self.sparse_matrix.spmv_corrected2(img)).reshape(self.output_shape)\n            if self.normalized:\n                errors = np.divide(errors, norm, out=np.zeros_like(errors), where=norm!=0.0)\n\n        if signal.ndim == 1: # must be radial bins only, no eta, ie 1d.\n            if self.normalized:\n                signal = np.divide(signal, norm, out=np.zeros_like(signal), where=norm!=0.0)\n            self.norm_1d = norm\n            self.norm_2d = None\n            I = signal\n            if errors is not None:\n                errors_1d = errors\n            return I, errors_1d, None, None\n        else:  # will have eta bins\n            signal_1d =  np.sum(signal, axis=0)\n            self.norm_1d = np.sum(norm, axis=0)\n            if self.normalized:\n                signal_1d = np.divide(signal_1d, self.norm_1d, out=np.zeros_like(signal_1d), where=self.norm_1d!=0.0)\n                signal = np.divide(signal, norm, out=np.zeros_like(signal), where=norm!=0.0)\n            I = signal_1d\n            self.norm_2d = norm\n            I_2d = signal\n            if errors is not None:\n                errors_1d = np.sum(errors, axis=0)\n                errors_2d = errors\n                if self.normalized:\n                    errors_1d = np.divide(errors_1d, self.norm_1d, out=np.zeros_like(errors_1d), where=self.norm_1d!=0.0)\n                    errors_2d = np.divide(errors_2d, norm, out=np.zeros_like(errors_2d), where=norm!=0.0)\n            return I, errors_1d, I_2d, errors_2d\n</code></pre>"},{"location":"azint-reference/#azint.azint.AzimuthalIntegrator.__init__","title":"<code>__init__(poni, n_splitting, radial_bins, azimuth_bins=None, unit='q', mask=None, solid_angle=True, polarization_factor=None, normalized=True, error_model=None)</code>","text":"<p>Initializes the integration settings for a 1D or 2D azimuthal integration.</p> <p>Attributes:</p> Name Type Description <code>poni</code> <code>str or dict or Poni</code> <p>Path to a PONI file or a Poni instance or a dictionary that defines the detector geometry.</p> <code>n_splitting</code> <code>int</code> <p>Number of subpixels per dimension for pixel splitting. Each image pixel is split into (n_splitting x n_splitting) subpixels.</p> <code>radial_bins</code> <code>int or Sequence</code> <p>Number of radial bins or an explicit sequence of radial bin edges (e.g., in \u00c5\u207b\u00b9 or degrees).</p> <code>azimuth_bins</code> <code>int or Sequence</code> <p>Number of azimuthal bins or a sequence of azimuthal bin edges (in degrees from 0 to 360). Required for 2D integration.</p> <code>unit</code> <code>str</code> <p>Unit for the radial axis. Typically 'q' (\u00c5\u207b\u00b9) or '2theta' (degrees).</p> <code>mask</code> <code>ndarray or str</code> <p>Mask array or path to mask file. Pixels marked with 1 will be excluded from the integration.</p> <code>solid_angle</code> <code>bool</code> <p>If True, applies solid angle correction.</p> <code>polarization_factor</code> <code>float</code> <p>Polarization correction factor. Use 1 for horizontal polarization, -1 for vertical polarization.</p> <code>normalized</code> <code>bool</code> <p>If True, the output will be normalized by the number of contributing pixels.</p> <code>error_model</code> <code>str</code> <p>Error model used to propagate uncertainties. Currently, only 'poisson' is supported.</p> <code>radial_axis</code> <code>ndarray</code> <p>Array of radial coordinates in the specified unit ('q' or '2theta').</p> <code>azimuth_axis</code> <code>ndarray</code> <p>Array of azimuthal coordinates in degrees, present if performing 2D integration.</p> Source code in <code>azint/azint.py</code> <pre><code>def __init__(self,\n             poni: Union[str, Poni],\n             n_splitting: int, \n             radial_bins: Union[int, Sequence],\n             azimuth_bins: Optional[Union[int, Sequence]] = None,\n             unit: str = 'q',\n             mask: Optional[Union[np.ndarray, str]] = None,\n             solid_angle: bool = True,\n             polarization_factor: Optional[float] = None,\n             normalized: bool = True,\n             error_model: Optional[str] = None):\n    \"\"\"\n    Initializes the integration settings for a 1D or 2D azimuthal integration.\n\n    Attributes:\n        poni (str or dict or Poni): Path to a PONI file or a Poni instance or a dictionary that defines the detector geometry.\n        n_splitting (int): Number of subpixels per dimension for pixel splitting. Each image pixel is split into (n_splitting x n_splitting) subpixels.\n        radial_bins (int or Sequence): Number of radial bins or an explicit sequence of radial bin edges (e.g., in \u00c5\u207b\u00b9 or degrees).\n        azimuth_bins (int or Sequence, optional): Number of azimuthal bins or a sequence of azimuthal bin edges (in degrees from 0 to 360). Required for 2D integration.\n        unit (str): Unit for the radial axis. Typically 'q' (\u00c5\u207b\u00b9) or '2theta' (degrees).\n        mask (ndarray or str, optional): Mask array or path to mask file. Pixels marked with 1 will be excluded from the integration.\n        solid_angle (bool): If True, applies solid angle correction.\n        polarization_factor (float, optional): Polarization correction factor.\n            Use 1 for horizontal polarization, -1 for vertical polarization.\n        normalized (bool, optional): If True, the output will be normalized by the number of contributing pixels.\n        error_model (str, optional): Error model used to propagate uncertainties. Currently, only 'poisson' is supported.\n\n        radial_axis (ndarray): Array of radial coordinates in the specified unit ('q' or '2theta').\n        azimuth_axis (ndarray, optional): Array of azimuthal coordinates in degrees, present if performing 2D integration.\n    \"\"\"\n    self.poni = poni\n    self.n_splitting = n_splitting\n    self.radial_bins = radial_bins\n    self.azimuth_bins = azimuth_bins\n    self.solid_angle = solid_angle\n    self.polarization_factor = polarization_factor\n    self.normalized = normalized\n    self.mask_path = ''\n    if not isinstance(mask, np.ndarray):\n        if mask is not None:\n            if mask == '':\n                mask = None\n            else:\n                fname = mask\n                self.mask_path = fname\n                ending = os.path.splitext(fname)[1]\n                if ending == '.npy':\n                    mask = np.load(fname)\n                else:\n                    mask = fabio.open(fname).data\n    self.mask = mask\n    if error_model and error_model != 'poisson':\n        raise RuntimeError('Only poisson error model is supported')\n\n    if unit not in ('q', '2th'):\n        raise RuntimeError('Wrong radial unit. Allowed units: q, 2th')\n\n    if isinstance(poni, str):\n        poni = Poni.from_file(poni)\n\n    if isinstance(poni, dict):\n        poni = Poni.from_dict(poni)\n\n    self.unit = unit\n    self.error_model = error_model\n\n    pixel_centers = np.mean(poni.det.pixel_corners, axis=2)\n    p1 = pixel_centers[..., 1] - poni.poni1\n    p2 = pixel_centers[..., 2] - poni.poni2\n    p3 = pixel_centers[..., 0] + poni.dist\n    tth, phi = transform(poni, p1, p2, p3)\n\n    radial_bins = setup_radial_bins(poni, radial_bins, unit, tth)\n    self.radial_axis = 0.5*(radial_bins[1:] + radial_bins[:-1])\n    azimuth_bins = setup_azimuth_bins(azimuth_bins)\n    self.azimuth_axis = 0.5*(azimuth_bins[1:] + azimuth_bins[:-1]) if azimuth_bins is not None else None\n\n    shape = pixel_centers.shape[:2]\n    self.input_size = np.prod(shape)\n    if mask is None:\n        mask = np.zeros(shape, dtype=np.int8)\n\n    if azimuth_bins is None:\n        self.output_shape = [len(radial_bins) - 1]\n    else:\n        self.output_shape = [len(azimuth_bins) - 1, len(radial_bins) - 1]\n\n    self.sparse_matrix = Sparse(poni, poni.det.pixel_corners, n_splitting, \n                                mask, unit, radial_bins, azimuth_bins)\n    self.norm = self.sparse_matrix.spmv(np.ones(shape[0]*shape[1], dtype=np.float32))\n    corrections = setup_corrections(poni, solid_angle, polarization_factor, p1, p2, tth, phi)\n    self.sparse_matrix.set_correction(corrections)\n</code></pre>"},{"location":"azint-reference/#azint.azint.AzimuthalIntegrator.integrate","title":"<code>integrate(img)</code>","text":"<p>Performs azimuthal integration on the input image.</p> <p>This function computes the azimuthally averaged intensity from the input image using a sparse matrix-based integration approach. Optionally applies a mask and computes error estimates if an error model is defined.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ndarray</code> <p>Input image to be integrated. Must match expected input size.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[ndarray, ndarray]</code> <ul> <li>I (ndarray): 1D azimuthally integrated intensity.</li> <li>errors_1d (ndarray or None): Standard error of the mean (SEM) for 1D integration if error model is specified, else None.</li> <li>I_2d (None): 2D \"cake\" integration result.</li> <li>errors_2d (None): 2D error result.</li> </ul> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the input image size does not match the expected size.</p> Source code in <code>azint/azint.py</code> <pre><code>def integrate(self, \n              img: np.ndarray) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Performs azimuthal integration on the input image.\n\n    This function computes the azimuthally averaged intensity from the input image\n    using a sparse matrix-based integration approach. Optionally applies a mask\n    and computes error estimates if an error model is defined.\n\n    Args:\n        img (ndarray): Input image to be integrated. Must match expected input size.\n\n    Returns:\n        tuple:\n            - I (ndarray): 1D azimuthally integrated intensity.\n            - errors_1d (ndarray or None): Standard error of the mean (SEM) for 1D integration if error model is specified, else None.\n            - I_2d (None): 2D \"cake\" integration result.\n            - errors_2d (None): 2D error result.\n\n    Raises:\n        RuntimeError: If the input image size does not match the expected size.\n    \"\"\"\n    img = np.ascontiguousarray(img)\n\n    if img.size != self.input_size:\n        raise RuntimeError('Size of image is wrong!\\nExpected %d\\nActual size %d' %(self.input_size, img.size))\n    if self.mask is None:\n        norm = self.norm\n    else:\n        inverted_mask = 1 - self.mask\n        img = img*inverted_mask\n        norm = self.sparse_matrix.spmv(inverted_mask.reshape(-1))\n\n    signal = self.sparse_matrix.spmv_corrected(img).reshape(self.output_shape)\n    norm = norm.reshape(self.output_shape)\n\n    errors = None\n    errors_1d = None\n    errors_2d = None\n    if self.error_model:\n        # poisson error model\n        errors = np.sqrt(self.sparse_matrix.spmv_corrected2(img)).reshape(self.output_shape)\n        if self.normalized:\n            errors = np.divide(errors, norm, out=np.zeros_like(errors), where=norm!=0.0)\n\n    if signal.ndim == 1: # must be radial bins only, no eta, ie 1d.\n        if self.normalized:\n            signal = np.divide(signal, norm, out=np.zeros_like(signal), where=norm!=0.0)\n        self.norm_1d = norm\n        self.norm_2d = None\n        I = signal\n        if errors is not None:\n            errors_1d = errors\n        return I, errors_1d, None, None\n    else:  # will have eta bins\n        signal_1d =  np.sum(signal, axis=0)\n        self.norm_1d = np.sum(norm, axis=0)\n        if self.normalized:\n            signal_1d = np.divide(signal_1d, self.norm_1d, out=np.zeros_like(signal_1d), where=self.norm_1d!=0.0)\n            signal = np.divide(signal, norm, out=np.zeros_like(signal), where=norm!=0.0)\n        I = signal_1d\n        self.norm_2d = norm\n        I_2d = signal\n        if errors is not None:\n            errors_1d = np.sum(errors, axis=0)\n            errors_2d = errors\n            if self.normalized:\n                errors_1d = np.divide(errors_1d, self.norm_1d, out=np.zeros_like(errors_1d), where=self.norm_1d!=0.0)\n                errors_2d = np.divide(errors_2d, norm, out=np.zeros_like(errors_2d), where=norm!=0.0)\n        return I, errors_1d, I_2d, errors_2d\n</code></pre>"}]}