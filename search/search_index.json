{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"azint Installation conda install -c maxiv azint Getting started import fabio import numpy as np from azint import AzimuthalIntegrator img = fabio . open ( 'Eiger4M_Al2O3_13.45keV.edf' ) . data mask = fabio . open ( 'mask.tif' ) . data ai = AzimuthalIntegrator ( 'test.poni' , mask . shape , 75.0e-6 , 4 , [ 2000 ,], solid_angle = True ) res = ai . integrate ( img )","title":"Home"},{"location":"#azint","text":"","title":"azint"},{"location":"#installation","text":"conda install -c maxiv azint","title":"Installation"},{"location":"#getting-started","text":"import fabio import numpy as np from azint import AzimuthalIntegrator img = fabio . open ( 'Eiger4M_Al2O3_13.45keV.edf' ) . data mask = fabio . open ( 'mask.tif' ) . data ai = AzimuthalIntegrator ( 'test.poni' , mask . shape , 75.0e-6 , 4 , [ 2000 ,], solid_angle = True ) res = ai . integrate ( img )","title":"Getting started"},{"location":"azint-reference/","text":"AzimuthalIntegrator This class is an azimuthal integrator __init__ ( self , poni_file , shape , pixel_size , n_splitting , bins , mask = None , solid_angle = True ) special Parameters: Name Type Description Default poni_file str Name of Poni file that sets up the geometry of the integrator required shape tuple Shape of the images to be integrated required pixel_size float Pixel size of detector required n_splitting int Each pixel in the image gets split into (n, n) subpixels that get binned individually required bins list list of q and optionally phi bins. q bins can either be number of bins or a sequence defining the bin edges. Phi bins is a sequence required mask ndarray Pixel mask to exclude bad pixels. Pixels marked with 1 will be excluded None solid_angle bool Perform solid angle correction True Source code in azint/azint.py def __init__ ( self , poni_file : str , shape : tuple [ int , int ], pixel_size : float , n_splitting : int , bins : list [ Union [ int , Sequence ], Optional [ Sequence ]], mask : np . ndarray = None , solid_angle : bool = True ): \"\"\" Args: poni_file: Name of Poni file that sets up the geometry of the integrator shape: Shape of the images to be integrated pixel_size: Pixel size of detector n_splitting: Each pixel in the image gets split into (n, n) subpixels that get binned individually bins: list of q and optionally phi bins. q bins can either be number of bins or a sequence defining the bin edges. Phi bins is a sequence mask: Pixel mask to exclude bad pixels. Pixels marked with 1 will be excluded solid_angle: Perform solid angle correction \"\"\" self . poni = Poni ( poni_file ) qbins = bins [ 0 ] if not any ([ isinstance ( qbins , np . ndarray ), isinstance ( qbins , list )]): minq = calculate_minq ( shape , self . poni , pixel_size ) maxq = calculate_maxq ( shape , self . poni , pixel_size ) bins [ 0 ] = np . linspace ( minq , maxq , qbins + 1 ) self . q = 0.5 * ( bins [ 0 ][ 1 :] + bins [ 0 ][: - 1 ]) if len ( bins ) == 2 : self . phi = 0.5 * ( bins [ 1 ][ 1 :] + bins [ 1 ][: - 1 ]) else : self . phi = None if mask is None : mask = np . zeros ( shape , dtype = np . uint8 ) self . output_shape = [ len ( axis ) - 1 for axis in bins [:: - 1 ]] self . sparse_matrix = Sparse ( self . poni , shape , pixel_size , n_splitting , mask , bins ) if solid_angle : d1 = ( np . arange ( shape [ 0 ], dtype = np . float32 ) + 0.5 ) * pixel_size - self . poni . poni1 d2 = ( np . arange ( shape [ 1 ], dtype = np . float32 ) + 0.5 ) * pixel_size - self . poni . poni2 p1 , p2 = np . meshgrid ( d2 , d1 ) solid_angle = self . poni . dist / np . sqrt ( self . poni . dist ** 2 + p1 * p1 + p2 * p2 ) self . norm = self . sparse_matrix . spmv ( solid_angle ** 3 ) self . correction = solid_angle ** 3 else : self . correction = None self . norm = self . sparse_matrix . spmv ( np . ones ( shape [ 0 ] * shape [ 1 ], dtype = np . float32 )) integrate ( self , img , mask = None ) Calculate the azimuthal integrated profile Parameters: Name Type Description Default img ndarray Input image to be integrated required mask ndarray Optional pixel mask to exclude bad pixels. Note if mask is constant using the mask argument in the constructor is more efficient None Returns: Type Description ndarray azimuthal integrated image Source code in azint/azint.py def integrate ( self , img : np . ndarray , mask : np . ndarray = None ) -> np . ndarray : \"\"\" Calculate the azimuthal integrated profile Args: img: Input image to be integrated mask: Optional pixel mask to exclude bad pixels. Note if mask is constant using the mask argument in the constructor is more efficient Returns: azimuthal integrated image \"\"\" if mask is None : norm = self . norm else : inverted_mask = 1 - mask img = img * inverted_mask if self . correction is not None : norm = self . sparse_matrix . spmv ( inverted_mask * self . correction ) else : norm = self . sparse_matrix . spmv ( inverted_mask ) signal = self . sparse_matrix . spmv ( img ) result = np . divide ( signal , norm , out = np . zeros_like ( signal ), where = self . norm != 0.0 ) return result . reshape ( self . output_shape )","title":"azint"},{"location":"azint-reference/#azint.azint.AzimuthalIntegrator","text":"This class is an azimuthal integrator","title":"AzimuthalIntegrator"},{"location":"azint-reference/#azint.azint.AzimuthalIntegrator.__init__","text":"Parameters: Name Type Description Default poni_file str Name of Poni file that sets up the geometry of the integrator required shape tuple Shape of the images to be integrated required pixel_size float Pixel size of detector required n_splitting int Each pixel in the image gets split into (n, n) subpixels that get binned individually required bins list list of q and optionally phi bins. q bins can either be number of bins or a sequence defining the bin edges. Phi bins is a sequence required mask ndarray Pixel mask to exclude bad pixels. Pixels marked with 1 will be excluded None solid_angle bool Perform solid angle correction True Source code in azint/azint.py def __init__ ( self , poni_file : str , shape : tuple [ int , int ], pixel_size : float , n_splitting : int , bins : list [ Union [ int , Sequence ], Optional [ Sequence ]], mask : np . ndarray = None , solid_angle : bool = True ): \"\"\" Args: poni_file: Name of Poni file that sets up the geometry of the integrator shape: Shape of the images to be integrated pixel_size: Pixel size of detector n_splitting: Each pixel in the image gets split into (n, n) subpixels that get binned individually bins: list of q and optionally phi bins. q bins can either be number of bins or a sequence defining the bin edges. Phi bins is a sequence mask: Pixel mask to exclude bad pixels. Pixels marked with 1 will be excluded solid_angle: Perform solid angle correction \"\"\" self . poni = Poni ( poni_file ) qbins = bins [ 0 ] if not any ([ isinstance ( qbins , np . ndarray ), isinstance ( qbins , list )]): minq = calculate_minq ( shape , self . poni , pixel_size ) maxq = calculate_maxq ( shape , self . poni , pixel_size ) bins [ 0 ] = np . linspace ( minq , maxq , qbins + 1 ) self . q = 0.5 * ( bins [ 0 ][ 1 :] + bins [ 0 ][: - 1 ]) if len ( bins ) == 2 : self . phi = 0.5 * ( bins [ 1 ][ 1 :] + bins [ 1 ][: - 1 ]) else : self . phi = None if mask is None : mask = np . zeros ( shape , dtype = np . uint8 ) self . output_shape = [ len ( axis ) - 1 for axis in bins [:: - 1 ]] self . sparse_matrix = Sparse ( self . poni , shape , pixel_size , n_splitting , mask , bins ) if solid_angle : d1 = ( np . arange ( shape [ 0 ], dtype = np . float32 ) + 0.5 ) * pixel_size - self . poni . poni1 d2 = ( np . arange ( shape [ 1 ], dtype = np . float32 ) + 0.5 ) * pixel_size - self . poni . poni2 p1 , p2 = np . meshgrid ( d2 , d1 ) solid_angle = self . poni . dist / np . sqrt ( self . poni . dist ** 2 + p1 * p1 + p2 * p2 ) self . norm = self . sparse_matrix . spmv ( solid_angle ** 3 ) self . correction = solid_angle ** 3 else : self . correction = None self . norm = self . sparse_matrix . spmv ( np . ones ( shape [ 0 ] * shape [ 1 ], dtype = np . float32 ))","title":"__init__()"},{"location":"azint-reference/#azint.azint.AzimuthalIntegrator.integrate","text":"Calculate the azimuthal integrated profile Parameters: Name Type Description Default img ndarray Input image to be integrated required mask ndarray Optional pixel mask to exclude bad pixels. Note if mask is constant using the mask argument in the constructor is more efficient None Returns: Type Description ndarray azimuthal integrated image Source code in azint/azint.py def integrate ( self , img : np . ndarray , mask : np . ndarray = None ) -> np . ndarray : \"\"\" Calculate the azimuthal integrated profile Args: img: Input image to be integrated mask: Optional pixel mask to exclude bad pixels. Note if mask is constant using the mask argument in the constructor is more efficient Returns: azimuthal integrated image \"\"\" if mask is None : norm = self . norm else : inverted_mask = 1 - mask img = img * inverted_mask if self . correction is not None : norm = self . sparse_matrix . spmv ( inverted_mask * self . correction ) else : norm = self . sparse_matrix . spmv ( inverted_mask ) signal = self . sparse_matrix . spmv ( img ) result = np . divide ( signal , norm , out = np . zeros_like ( signal ), where = self . norm != 0.0 ) return result . reshape ( self . output_shape )","title":"integrate()"}]}