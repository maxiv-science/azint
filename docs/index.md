# azint 

azint is a python library for azimuthal integration of area detectors.
The azimuthal integration is transformed into a sparse matrix vector multiplication for performance. Pixel splitting is done by subdividing 
each pixels into subpixels and assigning bins and weights for the individual subpixels. This can increase the precision of the transformation but also introduces correlation between neighboring bins.

The algorithm is described in more detail in this [publication](https://doi.org/10.1107/S1600577522008232). Please cite the paper if you use azint.

$$
I_{bin} = \frac{ \sum_{pix \in bin} c^{pix}_{bin} \frac{I_{pix}}{\Omega_{pix} P_{pix}}}{\sum_{pix \in bin}c^{pix}_{bin}}
$$

with the standard error of the mean

$$
SE_{bin} = \frac{ \sqrt{\sum_{pix \in bin} (c^{pix}_{bin})^2 \frac{\sigma^2_{pix}}{\Omega_{pix}^2 P_{pix}^2}}}{\sum_{pix \in bin}c^{pix}_{bin}}
$$

The only error model implementent at the moment is the poisson error model with
$\sigma_{pix} = \sqrt{I_{pix}}$
## Geometry
The geometry in azint is identical to [pyFAI](https://pyfai.readthedocs.io) to be compatible with poni files generated by pyFAI 
![poni](https://pyfai.readthedocs.io/en/master/_images/PONI.png)

## Installation
``` bash
conda install -c maxiv azint
```

## Getting started
azint is using poni files from [pyFAI](https://pyfai.readthedocs.io) to setup the azimuthal integrator
([link](https://zenodo.org/records/15744977?token=eyJhbGciOiJIUzUxMiJ9.eyJpZCI6IjQxMTA4MjgzLWQ5ODUtNGE3MS04MGU4LTI4MzgwYzAwNDNlYiIsImRhdGEiOnt9LCJyYW5kb20iOiIzOTI4ZmM1YzRhODgwODI3ZDU0ZGVjYTYxNmViNTg0NyJ9.lt_pXKDYR6t29tGKqcm6huHzvgeqlwc5U5I9TXJ5-LQlL865aGLQE7B6-h6ZS7PLQ7yEGf6M3jV1HacXVpSPiA) to file examples and output)
``` python
import numpy as np
from azint import AzimuthalIntegrator

# ------------------------------
# Load detector image and setup
# ------------------------------

# Path to the input HDF5 file containing detector data
h5name = "scan-1737_pilatus.h5"
h = h5py.File(h5name, 'r')

# Extract a single image frame from the dataset
img = h['/entry/instrument/pilatus/data'][10]

# Path to the detector calibration file
poni = 'Si_135mm.poni'

# Path to the mask file for bad pixels or beamstop
mask = 'hot_px_bs_mask.npy'


# ------------------------------
# Azimuthal integration settings
# ------------------------------

config = {
    'poni': poni,                     # Detector geometry calibration file
    'mask': mask,                     # Mask to ignore hot/dead pixels
    'radial_bins': 3000,              # Number of radial bins
    'azimuth_bins': 180,              # Number of azimuthal bins (set to None for 1D only)
    'n_splitting': 21,                # Pixel subdivision for integration precision
    'error_model': 'poisson',         # Error model for propagation
    'solid_angle': True,              # Apply solid angle correction
    'polarization_factor': 0.965,     # Correction for polarization effects
    'normalized': True,               # Normalize intensity values
    'unit': '2th',                    # Output units (e.g., '2th' for 2Î¸)
}

ai = AzimuthalIntegrator(**config)
I, errors_1d, I_2d, errors_2d = ai.integrate(img)

import matplotlib.pyplot as plt
plt.figure()
plt.plot(ai.radial_axis, I)

plt.figure()
plt.imshow(I_2d)

```
